/**
 * Feature File Generation and Management Module
 * Handles creation and parsing of Runix feature files for test automation
 */

const fs = require('fs').promises;
const path = require('path');

/**
 * Generates a feature file from execution history and observations
 * @param {string} goal - The goal that was accomplished
 * @param {Array} executionHistory - History of executed steps
 * @param {Array} observations - User observations (for editor mode)
 * @param {Object} sessionContext - Session context information
 * @returns {Promise<string>} Generated feature file content
 */
async function generateFeatureFile(goal, executionHistory = [], observations = [], sessionContext = {}) {
  console.log(`Generating feature file for goal: ${goal}`);
  
  const timestamp = new Date();
  const featureId = `feature-${timestamp.getTime()}`;
  
  // Create feature file header
  let featureContent = `# Feature: ${goal}\n`;
  featureContent += `# Generated: ${timestamp.toISOString()}\n`;
  featureContent += `# Session ID: ${sessionContext.sessionId || 'unknown'}\n`;
  featureContent += `# Mode: ${sessionContext.mode || 'unknown'}\n\n`;
  
  // Add feature description
  featureContent += `Feature: ${goal}\n`;
  featureContent += `  As a user\n`;
  featureContent += `  I want to ${goal.toLowerCase()}\n`;
  featureContent += `  So that I can accomplish my task efficiently\n\n`;
  
  // Add scenario
  featureContent += `  Scenario: Complete task - ${goal}\n`;
  
  // Process execution history into steps
  if (executionHistory.length > 0) {
    featureContent += `    # Execution Steps:\n`;
    for (let i = 0; i < executionHistory.length; i++) {
      const step = executionHistory[i];
      const stepText = formatStepForFeatureFile(step, i + 1);
      featureContent += `    ${stepText}\n`;
    }
  }
  
  // Process observations into steps
  if (observations.length > 0) {
    featureContent += `    # Observed User Actions:\n`;
    for (let i = 0; i < observations.length; i++) {
      const observation = observations[i];
      const stepText = formatObservationForFeatureFile(observation, i + 1);
      featureContent += `    ${stepText}\n`;
    }
  }
  
  // Add verification steps
  featureContent += `    # Verification:\n`;
  featureContent += `    Then the task should be completed successfully\n`;
  featureContent += `    And the user should see the expected result\n\n`;
  
  // Add metadata section
  featureContent += `# Metadata:\n`;
  featureContent += `# - Execution Time: ${sessionContext.executionTime || 'unknown'}\n`;
  featureContent += `# - Steps Count: ${executionHistory.length + observations.length}\n`;
  featureContent += `# - Success Rate: ${calculateSuccessRate(executionHistory)}\n`;
  featureContent += `# - Generated By: AI Driver v${require('../../package.json').version || '1.0.0'}\n`;
  
  return featureContent;
}

/**
 * Formats an execution step for inclusion in a feature file
 * @param {Object} step - Execution step object
 * @param {number} stepNumber - Step number
 * @returns {string} Formatted step text
 */
function formatStepForFeatureFile(step, stepNumber) {
  const action = step.action || 'unknown';
  const description = step.description || `Step ${stepNumber}`;
  
  switch (action.toLowerCase()) {
    case 'click':
      return `When I click on "${step.target || 'element'}"`;
    case 'type':
      return `When I type "${step.value || 'text'}" into "${step.target || 'field'}"`;
    case 'key':
      return `When I press the "${step.value || 'key'}" key`;
    case 'scroll':
      return `When I scroll ${step.direction || 'down'} on the page`;
    case 'wait':
      return `And I wait for ${step.value || 1000}ms`;
    case 'screenshot':
      return `And I take a screenshot`;
    case 'analyze':
      return `Then I analyze the current screen state`;
    default:
      return `When I ${description.toLowerCase()}`;
  }
}

/**
 * Formats a user observation for inclusion in a feature file
 * @param {Object} observation - User observation object
 * @param {number} stepNumber - Step number
 * @returns {string} Formatted observation text
 */
function formatObservationForFeatureFile(observation, stepNumber) {
  const action = observation.action || 'unknown';
  const description = observation.description || `User action ${stepNumber}`;
  
  switch (action.toLowerCase()) {
    case 'click':
      return `Given the user clicks on "${observation.target || 'element'}"`;
    case 'type':
      return `Given the user types "${observation.value || 'text'}" into "${observation.target || 'field'}"`;
    case 'navigate':
      return `Given the user navigates to "${observation.url || 'page'}"`;
    case 'select':
      return `Given the user selects "${observation.value || 'option'}" from "${observation.target || 'dropdown'}"`;
    default:
      return `Given the user ${description.toLowerCase()}`;
  }
}

/**
 * Calculates success rate from execution history
 * @param {Array} executionHistory - History of executed steps
 * @returns {string} Success rate as percentage
 */
function calculateSuccessRate(executionHistory) {
  if (executionHistory.length === 0) return '0%';
  
  const successfulSteps = executionHistory.filter(step => 
    step.success === true || step.result?.success === true
  ).length;
  
  const rate = (successfulSteps / executionHistory.length) * 100;
  return `${rate.toFixed(1)}%`;
}

/**
 * Saves a feature file to the features directory
 * @param {string} featureContent - Content of the feature file
 * @param {string} filename - Optional filename (will be generated if not provided)
 * @returns {Promise<string>} Path to the saved feature file
 */
async function saveFeatureFile(featureContent, filename = null) {
  const featuresDir = path.join(__dirname, '../../features');
  
  // Ensure features directory exists
  try {
    await fs.mkdir(featuresDir, { recursive: true });
  } catch (error) {
    console.warn('Could not create features directory:', error.message);
  }
  
  // Generate filename if not provided
  if (!filename) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    filename = `feature-${timestamp}.feature`;
  }
  
  // Ensure .feature extension
  if (!filename.endsWith('.feature')) {
    filename += '.feature';
  }
  
  const filePath = path.join(featuresDir, filename);
  
  try {
    await fs.writeFile(filePath, featureContent, 'utf8');
    console.log(`Feature file saved: ${filePath}`);
    return filePath;
  } catch (error) {
    console.error('Error saving feature file:', error);
    throw error;
  }
}

/**
 * Parses a Runix feature file content
 * @param {string} featureContent - Content of the feature file
 * @returns {Object} Parsed feature file structure
 */
function parseRunixFeatureFile(featureContent) {
  console.log('Parsing Runix feature file...');
  
  const lines = featureContent.split('\n');
  const parsedFeature = {
    title: '',
    description: '',
    scenarios: [],
    metadata: {}
  };
  
  let currentSection = 'header';
  let currentScenario = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines and comments
    if (!line || line.startsWith('#')) {
      // Extract metadata from comments
      if (line.startsWith('# ') && line.includes(':')) {
        const [key, value] = line.substring(2).split(':').map(s => s.trim());
        parsedFeature.metadata[key] = value;
      }
      continue;
    }
    
    // Feature title
    if (line.startsWith('Feature:')) {
      parsedFeature.title = line.substring(8).trim();
      currentSection = 'description';
      continue;
    }
    
    // Scenario
    if (line.startsWith('Scenario:')) {
      if (currentScenario) {
        parsedFeature.scenarios.push(currentScenario);
      }
      currentScenario = {
        title: line.substring(9).trim(),
        steps: []
      };
      currentSection = 'scenario';
      continue;
    }
    
    // Steps
    if (currentSection === 'scenario' && currentScenario) {
      if (line.match(/^\s*(Given|When|Then|And)\s+/)) {
        const step = parseFeatureStep(line);
        if (step) {
          currentScenario.steps.push(step);
        }
      } else if (line.trim().length > 0) {
        // Description lines
        if (currentSection === 'description') {
          parsedFeature.description += line + '\n';
        }
      }
    }
  }
  
  // Add the last scenario
  if (currentScenario) {
    parsedFeature.scenarios.push(currentScenario);
  }
  
  console.log(`Parsed feature file: ${parsedFeature.title} with ${parsedFeature.scenarios.length} scenarios`);
  return parsedFeature;
}

/**
 * Parses a single feature file step
 * @param {string} stepLine - Step line from feature file
 * @returns {Object|null} Parsed step object
 */
function parseFeatureStep(stepLine) {
  const stepMatch = stepLine.match(/^\s*(Given|When|Then|And)\s+(.+)$/);
  if (!stepMatch) return null;
  
  const [, keyword, text] = stepMatch;
  
  // Parse different step patterns
  let action, target, value;
  
  // Click patterns
  if (text.match(/click on "([^"]+)"/i)) {
    const match = text.match(/click on "([^"]+)"/i);
    action = 'click';
    target = match[1];
  }
  // Type patterns
  else if (text.match(/type "([^"]+)" into "([^"]+)"/i)) {
    const match = text.match(/type "([^"]+)" into "([^"]+)"/i);
    action = 'type';
    value = match[1];
    target = match[2];
  }
  // Key press patterns
  else if (text.match(/press the "([^"]+)" key/i)) {
    const match = text.match(/press the "([^"]+)" key/i);
    action = 'key';
    value = match[1];
  }
  // Wait patterns
  else if (text.match(/wait for (\d+)ms/i)) {
    const match = text.match(/wait for (\d+)ms/i);
    action = 'wait';
    value = parseInt(match[1]);
  }
  // Screenshot patterns
  else if (text.match(/take a screenshot/i)) {
    action = 'screenshot';
  }
  // Generic patterns
  else {
    action = 'generic';
    target = text;
  }
  
  return {
    keyword: keyword,
    text: text,
    action: action,
    target: target,
    value: value
  };
}

/**
 * Lists all available feature files
 * @returns {Promise<Array>} Array of feature file information
 */
async function listFeatureFiles() {
  const featuresDir = path.join(__dirname, '../../features');
  
  try {
    const files = await fs.readdir(featuresDir);
    const featureFiles = files.filter(file => file.endsWith('.feature'));
    
    const fileList = [];
    for (const file of featureFiles) {
      const filePath = path.join(featuresDir, file);
      const stats = await fs.stat(filePath);
      fileList.push({
        name: file,
        path: filePath,
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime
      });
    }
    
    return fileList;
  } catch (error) {
    console.error('Error listing feature files:', error);
    return [];
  }
}

/**
 * Loads and parses a feature file
 * @param {string} filePath - Path to the feature file
 * @returns {Promise<Object>} Parsed feature file
 */
async function loadFeatureFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf8');
    return parseRunixFeatureFile(content);
  } catch (error) {
    console.error('Error loading feature file:', error);
    throw error;
  }
}

module.exports = {
  generateFeatureFile,
  saveFeatureFile,
  parseRunixFeatureFile,
  parseFeatureStep,
  listFeatureFiles,
  loadFeatureFile,
  formatStepForFeatureFile,
  formatObservationForFeatureFile,
  calculateSuccessRate
};
